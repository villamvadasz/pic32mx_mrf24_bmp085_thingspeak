/*******************************************************************************
  Company:
    Microchip Technology Inc.

  File Name:
    smtp_demo.c

  Summary:
    - SMTP Client (short message)
    - SMTP Client (long message, not enabled)

  Description:
     SMTP Client Demonstrations


 *******************************************************************************/

//DOM-IGNORE-BEGIN
/*******************************************************************************
Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.

Microchip licenses to you the right to use, modify, copy and distribute
Software only when embedded on a Microchip microcontroller or digital signal
controller that is integrated into your product or third party product
(pursuant to the sublicense terms in the accompanying license agreement).

You should refer to the license agreement accompanying this Software for
additional information regarding your rights and obligations.

SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
 *******************************************************************************/
//DOM-IGNORE-END

#define __SMTPDEMO_C_

#include "system_config.h"

#if defined(STACK_USE_SMTP_CLIENT)

#include "tcpip.h"


unsigned int smtp_trigger_email = 1;
unsigned int smtp_result_email = 0;
/*****************************************************************************
  Function:
    void SMTPDemo(void)

  Summary:
    Demonstrates use of the e-mail (SMTP) client.

  Description:
    This function demonstrates the use of the SMTP client.  The function is
    called periodically by the stack, and checks if BUTTON2 and BUTTON3 are
    pressed simultaneously.  If they are, it attempts to send an e-mail
    message using parameters hard coded in the function below.

    While the client is executing, LED1 will be used as a busy indicator.
    LED2 will light when the transmission has been completed successfully.
    If both LEDs extinguish, an error occurred.

    For an example of sending a longer message (one that does not exist in
    RAM all at once), see the commented secondary implementation of this
    function in this file (smtp_demo.c) below.  For an example of sending
    a message using parameters gathered at run time, and/or a message with
    attachments, see the implementation of HTTPPostEmail in custom_http_app.c.

  Precondition:
    The SMTP client is initialized.

  Parameters:
    None

  Returns:
    None
 ***************************************************************************/
void SMTPDemo(void)
{
    // Send an email once if someone pushes BUTTON2 and BUTTON3 at the same time
    // This is a simple message example, where the message
    // body must already be in RAM.
    // LED1 will be used as a busy indicator
    // LED2 will be used as a mail sent successfully indicator

    static enum {
        MAIL_HOME = 0,
        MAIL_BEGIN,
        MAIL_SMTP_FINISHING,
        MAIL_DONE
    } MailState = MAIL_HOME;
    static uint32_t WaitTime;

    switch (MailState) {
    case MAIL_HOME:
        if (smtp_trigger_email) {
            smtp_trigger_email = 0;
            putrsUART("Start sending email\r\n");
            // Start sending an email
            MailState++;
        }
        break;

    case MAIL_BEGIN:
        if (SMTPBeginUsage()) {
            // Note that these strings must stay allocated in
            // memory until SMTPIsBusy() returns false.  To
            // guarantee that the C compiler does not reuse this
            // memory, you must allocate the strings as static.

            static uint8_t RAMStringTo[] = "kyrk@villamvadasz.hu";
            //static uint8_t RAMStringCC[] = "foo@picsaregood.com, \"Jane Smith\" <jane.smith@picsaregood.com>";
            //static uint8_t RAMStringBCC[] = "";
            static uint8_t RAMStringBody[] = "Message generated by stack " TCPIP_STACK_VERSION " \r\n\r\nButtons: 3210";
            RAMStringBody[sizeof (RAMStringBody) - 2] = '0' + 0;
            RAMStringBody[sizeof (RAMStringBody) - 3] = '0' + 0;
            RAMStringBody[sizeof (RAMStringBody) - 4] = '0' + 0;
            RAMStringBody[sizeof (RAMStringBody) - 5] = '0' + 0;

            SMTPClient.Server.szROM = (ROM uint8_t *) "smtp.1und1.de"; // SMTP server address
            SMTPClient.ROMPointers.Server = 1;
            //SMTPClient.Username.szROM = (ROM uint8_t *)"kyrk.villamvadasz.hu";
            //SMTPClient.ROMPointers.Username = 1;
            //SMTPClient.Password.szROM = (ROM uint8_t *)"secretpassword";
            //SMTPClient.ROMPointers.Password = 1;
            SMTPClient.To.szRAM = RAMStringTo;
            SMTPClient.From.szROM = (ROM uint8_t *) "\"SMTP Service\" <kyrk@villamvadasz.hu>";
            SMTPClient.ROMPointers.From = 1;
            SMTPClient.Subject.szROM = (ROM uint8_t *) "Hello world!  SMTP Test.";
            SMTPClient.ROMPointers.Subject = 1;
            SMTPClient.Body.szRAM = RAMStringBody;
            SMTPClient.UseSSL = 1;
            SMTPSendMail();
            MailState++;
        }
        break;

    case MAIL_SMTP_FINISHING:
        if (!SMTPIsBusy()) {
            // Finished sending mail
            MailState++;
            WaitTime = TickGet();
            putrsUART("Finished sending email\r\n");
            smtp_result_email = (SMTPEndUsage() == SMTP_SUCCESS);
            if (smtp_result_email) {
                putrsUART("Success\r\n");
            } else {
                putrsUART("Failed\r\n");
            }
        }
        break;

    case MAIL_DONE:
        // Wait for the user to release BUTTON2 or BUTTON3 and for at
        // least 1 second to pass before allowing another
        // email to be sent.  This is merely to prevent
        // accidental flooding of email boxes while
        // developing code.  Your application may wish to
        // remove this.
        if (TickGet() - WaitTime > TICK_SECOND) {
                MailState = MAIL_HOME;
        }
        break;
    }
}

/*
void SMTPDemo(void)
{
    // Send an email once if someone pushes BUTTON2 and BUTTON3 simultaneously
    // This is a multi-part message example, where the message
    // body is dynamically generated and need not fit in RAM.
    // LED1 will be used as a busy indicator
    // LED2 will be used as a mail sent successfully indicator
    static enum
    {
        MAIL_HOME = 0,
        MAIL_BEGIN,
        MAIL_PUT_DATA,
        MAIL_PUT_DATA2,
        MAIL_SMTP_FINISHING,
        MAIL_DONE
    } MailState = MAIL_HOME;
    static uint8_t *MemPtr;
    static uint32_t WaitTime;

    switch (MailState)
    {
        case MAIL_HOME:
            if ((BUTTON2_IO == 0u) && (BUTTON3_IO == 0u))
            {
                // Start sending an email
                LED1_IO = 1;
                MailState++;
                LED2_IO = 0;
            }
            break;

        case MAIL_BEGIN:
            if (SMTPBeginUsage())
            {
                // Note that these strings must stay allocated in
                // memory until SMTPIsBusy() returns false.  To
                // guarantee that the C compiler does not reuse this
                // memory, you must allocate the strings as static.

                static uint8_t RAMStringTo[] = "joe@picsaregood.com";
                //static uint8_t RAMStringCC[] = "foo@picsaregood.com, \"Jane Smith\" <jane.smith@picsaregood.com>";

                SMTPClient.Server.szROM = "mail";   // SMTP server address
                SMTPClient.ROMPointers.Server = 1;
                //SMTPClient.Username.szROM = (ROM uint8_t *)"mchpboard";
                //SMTPClient.ROMPointers.Username = 1;
                //SMTPClient.Password.szROM = (ROM uint8_t *)"secretpassword";
                //SMTPClient.ROMPointers.Password = 1;
                SMTPClient.To.szRAM = RAMStringTo;
                //SMTPClient.CC.szRAM = RAMStringCC;
                SMTPClient.From.szROM = (ROM uint8_t *)"\"SMTP Service\" <mchpboard@picsaregood.com>";
                SMTPClient.ROMPointers.From = 1;
                SMTPClient.Subject.szROM = (ROM uint8_t *)"Hello world!  SMTP Test.";
                SMTPClient.ROMPointers.Subject = 1;
                SMTPSendMail();
                MailState++;
            }
            break;

        case MAIL_PUT_DATA:
            // Check to see if a failure occured
            if (!SMTPIsBusy())
            {
                // Finished sending mail
                LED1_IO = 0;
                MailState = MAIL_DONE;
                WaitTime = TickGet();
                LED2_IO = (SMTPEndUsage() == SMTP_SUCCESS);
                break;
            }

            if (SMTPIsPutReady() >= 121u)
            {
                SMTPPutROMString((ROM uint8_t *)"Hello!\r\n\r\nThis mail was automatically generated by Microchip TCP/IP Stack " TCPIP_STACK_VERSION ".\r\n\r\nThe following is a snapshot of RAM:\r\n");
                SMTPFlush();

                MemPtr = 0x0000;
                MailState++;
            }
            break;

        case MAIL_PUT_DATA2:
            // Check to see if a failure occured
            if (!SMTPIsBusy())
            {
                // Finished sending mail
                LED1_IO = 0;
                MailState = MAIL_DONE;
                WaitTime = TickGet();
                LED2_IO = (SMTPEndUsage() == SMTP_SUCCESS);
                break;
            }

            if (SMTPIsPutReady() >= 75u)
            {
                uint8_t i, c;
                TCPIP_UINT16_VAL w;

                // Write line address
                w.Val = (uint16_t)MemPtr;
                SMTPPut(btohexa_high(w.v[1]));
                SMTPPut(btohexa_low(w.v[1]));
                SMTPPut(btohexa_high(w.v[0]));
                SMTPPut(btohexa_low(w.v[0]));
                SMTPPut(' ');

                // Write data bytes in hex
                for (i = 0; i < 16u; i++)
                {
                    SMTPPut(' ');
                    #if defined(__XC32) // PIC32 has memory protection, so you can't just read from any old address
                        c = 'R';
                        MemPtr++;
                    #else
                        c = *MemPtr++;
                    #endif
                    SMTPPut(btohexa_high(c));
                    SMTPPut(btohexa_low(c));
                    if (i == 7u)
                        SMTPPut(' ');
                }

                SMTPPut(' ');
                SMTPPut(' ');

                // Write data bytes in ASCII
                MemPtr -= 16;
                for (i = 0; i < 16u; i++)
                {
                    #if defined(__XC32) // PIC32 has memory protection, so you can't just read from any old address
                        c = 'R';
                        MemPtr++;
                    #else
                        c = *MemPtr++;
                    #endif
                    if (c < ' ' || c > '~')
                        c = '.';
                    SMTPPut(c);

                    if (i == 7u)
                        SMTPPut(' ');
                }

                SMTPPut('\r');
                SMTPPut('\n');
                SMTPFlush();

                // Make sure not to read from memory above address 0x0E7F.
                // Doing so would disrupt volatile pointers, ERDPT, FSR0, FSR1, FSR2, etc.
                if ((uint16_t)MemPtr >= 0xE7Fu)
                {
                    SMTPPutDone();
                    MailState++;
                }
            }
            break;

        case MAIL_SMTP_FINISHING:
            // Check to see if we are done communicating with the SMTP server
            if (!SMTPIsBusy())
            {
                // Finished sending mail
                LED1_IO = 0;
                MailState = MAIL_DONE;
                WaitTime = TickGet();
                LED2_IO = (SMTPEndUsage() == SMTP_SUCCESS);
            }
            break;

        case MAIL_DONE:
            // Wait for the user to release BUTTON2 or BUTTON3 for at
            // least 1 second to pass before allowing another
            // email to be sent.  This is merely to prevent
            // accidental flooding of email boxes while
            // developing code.  Your application may wish to
            // remove this.
            if (BUTTON2_IO || BUTTON3_IO)
            {
                if (TickGet() - WaitTime > TICK_SECOND)
                    MailState = MAIL_HOME;
            }
            break;
    }
}
 */

#endif // #if defined(STACK_USE_SMTP_CLIENT)
